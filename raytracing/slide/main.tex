% !TeX root = main.tex
% main_presentation.tex
% Ray Tracing and Ray Casting Presentation
% Include the preamble: \input{raytracing_preamble.tex}

\input{../../preamble.tex}

% --- Presentation Details ---
\title{Ray Tracing \& Ray Casting}
\subtitle{Realistic Graphics Inpsired by Nature}
\author{\large Ashrafur Rahman}
\date{\small Adjunct Lecturer}
\institute{Department of Computer Science and Engineering\\ Bangladesh University of Engineering and Technology (BUET)}

\begin{document}

% --- Title Slide ---
\begin{frame}
    \titlepage
\end{frame}

% --- Table of Contents ---
\begin{frame}{Index}
    \footnotesize
    \vspace{1cm}
    \tableofcontents
\end{frame}

\include{overview}
\include{camera}
\include{ray}
\include{intersection}
\include{qa}
\include{references}

\end{document}
\endinput

% --- Section 6: From Casting to Tracing ---
\section{From Ray Casting to Ray Tracing}

\begin{frame}{Ray Casting vs Ray Tracing}
    \begin{center}
        \begin{tikzpicture}[scale=0.8]
            % Ray Casting
            \node[rectangle, draw, minimum width=3cm, minimum height=1.5cm, fill=PrimaryColor!20] at (0,2) {Ray Casting};
            \node[eye] (eye1) at (-1,1) {};
            \node[sphere] (obj1) at (1,1) {};
            \draw[ray] (eye1) -- (obj1);
            \node[below] at (0,0.2) {\small Primary rays only};

            % Arrow
            \draw[->, very thick, AccentColor] (0,0) -- (0,-1);
            \node[right] at (0.2,-0.5) {\textcolor{AccentColor}{Add secondary rays}};

            % Ray Tracing
            \node[rectangle, draw, minimum width=3cm, minimum height=2cm, fill=SecondaryColor!20] at (0,-3) {Ray Tracing};
            \node[eye] (eye2) at (-1,-2.5) {};
            \node[sphere] (obj2) at (1,-2.5) {};
            \draw[ray] (eye2) -- (obj2);
            \draw[reflectray] (obj2) -- (2,-1.5);
            \draw[shadowray] (0,-4) -- (obj2);
            \draw[lightray] (0.5,-4.5) -- (obj2);
            \node[below] at (0,-4.8) {\small Primary + Secondary rays};
        \end{tikzpicture}
    \end{center}

    \begin{columns}
        \begin{column}{0.5\textwidth}
            \begin{raybox}{Ray Casting}
                \begin{itemize}
                    \item Eye rays only
                    \item Direct illumination
                    \item Fast but limited
                    \item Good for basic scenes
                \end{itemize}
            \end{raybox}
        \end{column}
        \begin{column}{0.5\textwidth}
            \begin{raybox}{Ray Tracing}
                \begin{itemize}
                    \item Multiple ray types
                    \item Global illumination
                    \item Slower but realistic
                    \item Reflections, shadows, refraction
                \end{itemize}
            \end{raybox}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}{Secondary Rays: The Magic Ingredients}
    \begin{center}
        \begin{tikzpicture}[scale=0.9]
            % Main scene setup
            \node[eye] (eye) at (0,0) {\faIcon{eye}};
            \node[sphere] (sphere) at (4,0) {};
            \node[circle, fill=LightColor, minimum size=0.8cm] (light) at (2,3) {\faIcon{lightbulb}};
            \node[sphere] (mirror) at (6,2) {};

            % Primary ray
            \draw[ray, very thick] (eye) -- (sphere);
            \node[below] at (2,-0.3) {\raycolor{1. Primary Ray}};

            % Shadow ray
            \draw[shadowray] (sphere) -- (light);
            \node[right] at (3.5,1.8) {\textcolor{DarkGray}{2. Shadow Ray}};

            % Reflection ray
            \draw[reflectray] (sphere) -- (mirror);
            \node[above] at (5,1.2) {\textcolor{SecondaryColor}{3. Reflection Ray}};

            % Ground plane
            \draw[thick, ObjectColor] (-1,-1.5) -- (7,-1.5);
            \draw[refractray] (sphere) -- (4,-1.5);
            \node[right] at (4.2,-1) {\textcolor{AccentColor}{4. Refraction Ray}};

            % Labels
            \node[above] at (2,3.5) {\textcolor{LightColor}{Light Source}};
            \node[above] at (6,2.8) {\textcolor{ObjectColor}{Mirror}};
            \node[below] at (4,-0.8) {\textcolor{ObjectColor}{Main Object}};
        \end{tikzpicture}
    \end{center}
\end{frame}

\begin{frame}{Recursive Ray Tracing}
    \begin{center}
        \begin{tikzpicture}[scale=0.7]
            % Tree structure showing recursion
            \node[circle, draw, fill=PrimaryColor!30] (root) at (0,4) {Eye};

            % Level 1
            \node[circle, draw, fill=RayColor!30] (obj1) at (-2,2) {Obj1};
            \node[circle, draw, fill=RayColor!30] (obj2) at (2,2) {Obj2};

            % Level 2
            \node[circle, draw, fill=SecondaryColor!30] (mirror1) at (-3,0) {Mirror};
            \node[circle, draw, fill=AccentColor!30] (glass1) at (-1,0) {Glass};
            \node[circle, draw, fill=SecondaryColor!30] (mirror2) at (1,0) {Mirror};
            \node[circle, draw, fill=AccentColor!30] (glass2) at (3,0) {Glass};

            % Level 3
            \node[circle, draw, fill=ObjectColor!30] (final1) at (-3.5,-2) {Obj};
            \node[circle, draw, fill=ObjectColor!30] (final2) at (-2.5,-2) {Obj};
            \node[circle, draw, fill=ObjectColor!30] (final3) at (2.5,-2) {Obj};

            % Connections
            \draw[arrow] (root) -- (obj1);
            \draw[arrow] (root) -- (obj2);
            \draw[arrow] (obj1) -- (mirror1);
            \draw[arrow] (obj1) -- (glass1);
            \draw[arrow] (obj2) -- (mirror2);
            \draw[arrow] (obj2) -- (glass2);
            \draw[arrow] (mirror1) -- (final1);
            \draw[arrow] (glass1) -- (final2);
            \draw[arrow] (mirror2) -- (final3);

            % Depth labels
            \node[right] at (4,4) {\textcolor{PrimaryColor}{Depth 0}};
            \node[right] at (4,2) {\textcolor{RayColor}{Depth 1}};
            \node[right] at (4,0) {\textcolor{SecondaryColor}{Depth 2}};
            \node[right] at (4,-2) {\textcolor{ObjectColor}{Depth 3}};
        \end{tikzpicture}
    \end{center}

    \begin{conceptbox}{Recursion Control}
        \textbf{Base Cases:} Maximum depth reached OR ray contribution becomes negligible
    \end{conceptbox}
\end{frame}

% --- Section 7: Advanced Topics ---
\section{Advanced Ray Tracing Effects}

\begin{frame}{Mirror Reflections}
    \begin{columns}
        \begin{column}{0.5\textwidth}
            \begin{mathbox}{Reflection Law}
                Given incident ray $\mathbf{d}$ and surface normal $\mathbf{n}$:
                \begin{align}
                    \mathbf{r} & = \mathbf{d} - 2(\mathbf{d} \cdot \mathbf{n})\mathbf{n}
                \end{align}

                \vspace{0.5cm}
                \textbf{Physical principle:}\\
                Angle of incidence = Angle of reflection
            \end{mathbox}
        \end{column}
        \begin{column}{0.5\textwidth}
            \begin{tikzpicture}[scale=0.8]
                % Mirror surface
                \draw[thick, ObjectColor] (-0.5,0) -- (3.5,0);
                \node[below] at (1.5,-0.3) {\objectcolor{Mirror Surface}};

                % Normal vector
                \draw[->, thick, SecondaryColor] (1.5,0) -- (1.5,2);
                \node[right] at (1.5,2) {$\mathbf{n}$};

                % Incident ray
                \draw[ray] (0,1.5) -- (1.5,0);
                \node[above left] at (0.5,1) {$\mathbf{d}$};

                % Reflected ray
                \draw[reflectray] (1.5,0) -- (3,1.5);
                \node[above right] at (2.5,1) {$\mathbf{r}$};

                % Angle indicators
                \draw[thin] (1.5,0) -- (1.2,0.5);
                \draw[thin] (1.5,0) -- (1.8,0.5);
                \node[above] at (1.2,0.3) {$\theta$};
                \node[above] at (1.8,0.3) {$\theta$};

                % Intersection point
                \fill[AccentColor] (1.5,0) circle (2pt);
            \end{tikzpicture}
        \end{column}
    \end{columns}

    \begin{center}
        \begin{tikzpicture}[scale=0.6]
            % Depth progression
            \node[above] at (0,2) {\textbf{Reflection Depth}};

            \foreach \depth/\x in {0/0, 1/2.5, 2/5, 3/7.5} {
                    \begin{scope}[xshift=\x cm]
                        \draw[thick] (0,0) -- (2,0);
                        \node[eye] at (1,-1) {};
                        \draw[ray] (1,-1) -- (1,0);
                        \foreach \i in {1,...,\depth} {
                                \draw[reflectray] (1,0) -- (0.5+\i*0.3,0.8);
                            }
                        \node[below] at (1,-1.5) {Depth \depth};
                    \end{scope}
                }
        \end{tikzpicture}
    \end{center}
\end{frame}

\begin{frame}{Refraction and Snell's Law}
    \begin{columns}
        \begin{column}{0.5\textwidth}
            \begin{mathbox}{Snell's Law}
                \begin{align}
                    n_1 \sin\theta_1 & = n_2 \sin\theta_2
                \end{align}

                where:
                \begin{itemize}
                    \item $n_1, n_2$ = refractive indices
                    \item $\theta_1$ = incident angle
                    \item $\theta_2$ = refracted angle
                \end{itemize}

                \vspace{0.3cm}
                \textbf{Examples:}
                \begin{itemize}
                    \item Air: $n = 1.0$
                    \item Water: $n = 1.33$
                    \item Glass: $n = 1.5$
                \end{itemize}
            \end{mathbox}
        \end{column}
        \begin{column}{0.5\textwidth}
            \begin{tikzpicture}[scale=0.8]
                % Interface
                \draw[thick, ObjectColor] (-1,0) -- (3,0);
                \node[left] at (-1,0.5) {\small Air ($n_1$)};
                \node[left] at (-1,-0.5) {\small Glass ($n_2$)};

                % Normal
                \draw[->, SecondaryColor, dashed] (1,-2) -- (1,2);
                \node[right] at (1,2) {$\mathbf{n}$};

                % Incident ray
                \draw[ray] (0,1.5) -- (1,0);
                \node[above] at (0.3,1) {$\theta_1$};

                % Refracted ray
                \draw[refractray] (1,0) -- (1.3,-1.5);
                \node[below] at (1.2,-0.5) {$\theta_2$};

                % Angles
                \draw[thin] (1,0) arc (270:225:0.5);
                \draw[thin] (1,0) arc (270:300:0.5);

                % Critical angle illustration
                \node[right] at (3.5,0) {
                    \begin{minipage}{2cm}
                        \tiny
                        Total internal\\
                        reflection when\\
                        $\theta_1 > \theta_c$
                    \end{minipage}
                };
            \end{tikzpicture}
        \end{column}
    \end{columns}

    \begin{conceptbox}{Physical Intuition}
        Light bends when moving between materials with different densities
    \end{conceptbox}
\end{frame}

\begin{frame}{Shadows: The Absence of Light}
    \begin{center}
        \begin{tikzpicture}[scale=0.9]
            % Light source
            \node[circle, fill=LightColor, minimum size=1cm] (light) at (0,3) {\faIcon{sun}};
            \node[above] at (0,3.8) {\textcolor{LightColor}{Light Source}};

            % Occluding object
            \node[sphere] (occluder) at (2,2) {};
            \node[above] at (2,2.8) {\textcolor{ObjectColor}{Occluder}};

            % Target object
            \node[sphere] (target) at (5,0) {};
            \node[below] at (5,-0.8) {\textcolor{ObjectColor}{Target}};

            % Eye
            \node[eye] (eye) at (7,0) {\faIcon{eye}};

            % Primary ray from eye
            \draw[ray] (eye) -- (target);
            \node[above] at (6,0.2) {\raycolor{Primary}};

            % Shadow ray (blocked)
            \draw[shadowray] (target) -- (occluder);
            \draw[shadowray, dashed] (occluder) -- (light);
            \node[left] at (3.5,1.2) {\textcolor{DarkGray}{Shadow Ray}};
            \node[right] at (3.5,1.5) {\textcolor{AccentColor}{BLOCKED!}};

            % Shadow region
            \fill[pattern=north east lines, pattern color=gray] (2.5,1.5) -- (4,0.5) -- (6,-0.5) -- (5.5,0.5) -- cycle;
            \node[right] at (6,0.8) {\textcolor{DarkGray}{Shadow}};
        \end{tikzpicture}
    \end{center}

    \begin{raybox}{Shadow Ray Algorithm}
        \textbf{For each intersection point:}
        \begin{enumerate}
            \item Cast ray toward each light source
            \item Check if ray intersects any object before reaching light
            \item If blocked → point is in shadow
            \item If clear → point is illuminated
        \end{enumerate}
    \end{raybox}
\end{frame}

% --- Section 8: Implementation Challenges ---
\section{Implementation Challenges}

\begin{frame}{The Floating Point Precision Problem}
    \begin{center}
        \begin{tikzpicture}[scale=0.9]
            % Surface
            \draw[thick, ObjectColor] (-1,0) -- (4,0);
            \node[below] at (1.5,-0.3) {\objectcolor{Surface}};

            % True intersection point
            \fill[SecondaryColor] (2,0) circle (3pt);
            \node[above] at (2,0.3) {\textcolor{SecondaryColor}{True intersection}};

            % Computed intersection points (with error)
            \fill[AccentColor] (1.95,-0.05) circle (2pt);
            \fill[AccentColor] (2.05,0.05) circle (2pt);
            \node[below] at (1.95,-0.3) {\textcolor{AccentColor}{Computed}};
            \node[above] at (2.05,0.3) {\textcolor{AccentColor}{Computed}};

            % Secondary rays from computed points
            \draw[reflectray] (1.95,-0.05) -- (1,1);
            \draw[shadowray] (2.05,0.05) -- (3,1);

            % Problems
            \node[right] at (4.5,0.5) {
                \begin{minipage}{3cm}
                    \textcolor{AccentColor}{\textbf{Problems:}}
                    \begin{itemize}
                        \item Self-intersection
                        \item Incorrect shadows
                        \item Ray escaping
                    \end{itemize}
                \end{minipage}
            };
        \end{tikzpicture}
    \end{center}

    \begin{conceptbox}{The Evil Epsilon}
        \textbf{Solution:} Add small offset $\varepsilon$ when starting secondary rays from surfaces\\
        \textbf{Challenge:} Too small → still problems; Too large → visible artifacts
    \end{conceptbox}
\end{frame}

\begin{frame}{Performance Considerations}
    \begin{columns}
        \begin{column}{0.5\textwidth}
            \begin{raybox}{Computational Complexity}
                \textbf{Basic ray tracing:}
                \begin{itemize}
                    \item $O(n \times m)$ where:
                    \item $n$ = number of pixels
                    \item $m$ = number of objects
                \end{itemize}

                \vspace{0.3cm}
                \textbf{With secondary rays:}
                \begin{itemize}
                    \item Exponential growth with depth
                    \item Multiple rays per intersection
                \end{itemize}
            \end{raybox}
        \end{column}
        \begin{column}{0.5\textwidth}
            \begin{tikzpicture}[scale=0.7]
                % Performance graph
                \begin{axis}[
                        width=6cm,
                        height=4cm,
                        xlabel={Scene Complexity},
                        ylabel={Render Time},
                        grid=major,
                        legend pos=north west
                    ]
                    \addplot[thick, PrimaryColor] coordinates {(1,1) (2,2) (3,3) (4,4) (5,5)};
                    \addplot[thick, AccentColor] coordinates {(1,1) (2,4) (3,9) (4,16) (5,25)};
                    \legend{Ray Casting, Ray Tracing}
                \end{axis}
            \end{tikzpicture}

            \vspace{0.3cm}
            \textbf{Optimization strategies:}
            \begin{itemize}
                \item Spatial data structures
                \item Early ray termination
                \item Parallel processing
            \end{itemize}
        \end{column}
    \end{columns}
\end{frame}

% --- Section 9: Acceleration Structures ---
\section{Acceleration Structures: Making Ray Tracing Fast}

\begin{frame}{The Naive Approach Problem}
    \begin{center}
        \begin{tikzpicture}[scale=0.8]
            % Ray
            \draw[ray, very thick] (0,0) -- (8,2);
            \node[below] at (0,0) {\raycolor{Ray}};

            % Many objects scattered
            \foreach \x/\y in {1/0.5, 2/1.8, 3/0.2, 4/1.5, 5/0.8, 6/1.2, 7/0.4} {
                    \node[sphere, scale=0.5] at (\x,\y) {};
                }

            % Intersection tests
            \foreach \x/\y in {1/0.5, 2/1.8, 3/0.2, 4/1.5, 5/0.8, 6/1.2, 7/0.4} {
                    \draw[dashed, red, thin] (0,0) -- (\x,\y);
                }

            \node[below] at (4,-1) {\textcolor{AccentColor}{\textbf{Problem:} Test every object for every ray!}};
            \node[below] at (4,-1.5) {Scene with 1M objects = 1M tests per ray};
        \end{tikzpicture}
    \end{center}

    \begin{conceptbox}{Computational Explosion}
        \textbf{Complexity:} For $N$ objects and $R$ rays → $O(N \times R)$ intersection tests\\
        \textbf{Real scenes:} Millions of triangles, millions of rays → Billions of tests!
    \end{conceptbox}
\end{frame}

\begin{frame}{Bounding Volume Hierarchy (BVH)}
    \begin{columns}
        \begin{column}{0.5\textwidth}
            \begin{raybox}{The Big Idea}
                \textbf{Divide and Conquer:}
                \begin{enumerate}
                    \item Group objects into bounding boxes
                    \item Build hierarchical tree structure
                    \item Test ray against boxes first
                    \item Only test objects in hit boxes
                \end{enumerate}
            \end{raybox}

            \vspace{0.3cm}
            \textbf{Key Benefits:}
            \begin{itemize}
                \item $O(\log N)$ instead of $O(N)$
                \item Massive speedup for complex scenes
                \item Works with any primitive type
            \end{itemize}
        \end{column}
        \begin{column}{0.5\textwidth}
            \begin{tikzpicture}[scale=0.7]
                % BVH Tree structure
                \node[rectangle, draw, fill=PrimaryColor!20, minimum width=3cm, minimum height=1cm] (root) at (0,3) {Root BBox};

                \node[rectangle, draw, fill=SecondaryColor!20, minimum width=1.3cm, minimum height=0.8cm] (left) at (-1.5,1.5) {Left BBox};
                \node[rectangle, draw, fill=SecondaryColor!20, minimum width=1.3cm, minimum height=0.8cm] (right) at (1.5,1.5) {Right BBox};

                \node[rectangle, draw, fill=AccentColor!20, minimum width=0.8cm, minimum height=0.6cm] (ll) at (-2.2,0) {LL};
                \node[rectangle, draw, fill=AccentColor!20, minimum width=0.8cm, minimum height=0.6cm] (lr) at (-0.8,0) {LR};
                \node[rectangle, draw, fill=AccentColor!20, minimum width=0.8cm, minimum height=0.6cm] (rl) at (0.8,0) {RL};
                \node[rectangle, draw, fill=AccentColor!20, minimum width=0.8cm, minimum height=0.6cm] (rr) at (2.2,0) {RR};

                % Tree connections
                \draw[arrow] (root) -- (left);
                \draw[arrow] (root) -- (right);
                \draw[arrow] (left) -- (ll);
                \draw[arrow] (left) -- (lr);
                \draw[arrow] (right) -- (rl);
                \draw[arrow] (right) -- (rr);

                % Ray traversal
                \draw[ray, very thick] (-3,2.5) -- (3,1);
                \node[below] at (0,-1) {\small \raycolor{Ray tests hierarchy top-down}};
            \end{tikzpicture}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}{BVH Construction and Traversal}
    \begin{columns}
        \begin{column}{0.5\textwidth}
            \begin{mathbox}{Construction Algorithm}
                \textbf{Recursive subdivision:}
                \begin{enumerate}
                    \item Compute bounding box for all objects
                    \item Choose split axis (longest dimension)
                    \item Sort objects by centroid
                    \item Split into two groups
                    \item Recursively build subtrees
                \end{enumerate}

                \vspace{0.3cm}
                \textbf{Split strategies:}
                \begin{itemize}
                    \item Median split
                    \item Surface Area Heuristic (SAH)
                    \item Spatial splits
                \end{itemize}
            \end{mathbox}
        \end{column}
        \begin{column}{0.5\textwidth}
            \begin{tikzpicture}[scale=0.7]
                % Scene with objects and bounding boxes
                \draw[thick, PrimaryColor] (-0.5,-0.5) rectangle (3.5,2.5);
                \draw[thick, SecondaryColor] (-0.3,-0.3) rectangle (1.3,1.3);
                \draw[thick, SecondaryColor] (1.7,0.7) rectangle (3.3,2.3);

                % Objects
                \node[sphere, scale=0.3] at (0,0) {};
                \node[sphere, scale=0.3] at (1,1) {};
                \node[triangle, scale=0.3] at (2,1) {};
                \node[sphere, scale=0.3] at (3,2) {};

                % Split line
                \draw[dashed, AccentColor, thick] (1.5,-0.5) -- (1.5,2.5);
                \node[right] at (1.6,1) {\textcolor{AccentColor}{Split}};

                % Ray traversal example
                \draw[ray] (-1,1.5) -- (4,0.5);

                \node[below] at (1.5,-1) {\small Spatial subdivision};
            \end{tikzpicture}

            \vspace{0.3cm}
            \begin{conceptbox}{Traversal}
                \textbf{Stack-based traversal:} Test bounding boxes, push hit children onto stack
            \end{conceptbox}
        \end{column}
    \end{columns}
\end{frame}

% --- Section 10: Hardware Acceleration ---
\section{Hardware Ray Tracing Revolution}

\begin{frame}{The Hardware Revolution}
    \begin{center}
        \begin{tikzpicture}[scale=0.9]
            % Timeline
            \draw[thick, PrimaryColor] (0,0) -- (8,0);

            % Milestones
            \node[above] at (1,0.5) {\textbf{2018}};
            \node[below] at (1,-0.5) {\textcolor{SecondaryColor}{NVIDIA RTX 20}};
            \fill[SecondaryColor] (1,0) circle (3pt);

            \node[above] at (3,0.5) {\textbf{2020}};
            \node[below] at (3,-0.5) {\textcolor{AccentColor}{RTX 30 Series}};
            \fill[AccentColor] (3,0) circle (3pt);

            \node[above] at (5,0.5) {\textbf{2021}};
            \node[below] at (5,-0.5) {\textcolor{ObjectColor}{Vulkan RT}};
            \fill[ObjectColor] (5,0) circle (3pt);

            \node[above] at (7,0.5) {\textbf{2022+}};
            \node[below] at (7,-0.5) {\textcolor{RayColor}{RDNA3, RTX 40}};
            \fill[RayColor] (7,0) circle (3pt);

            \node[below] at (4,-2) {\large \textcolor{PrimaryColor}{\textbf{From Software to Silicon}}};
        \end{tikzpicture}
    \end{center}

    \begin{columns}
        \begin{column}{0.5\textwidth}
            \textbf{Hardware Features:}
            \begin{itemize}
                \item Dedicated RT cores
                \item Hardware BVH traversal
                \item Triangle intersection units
                \item Tensor cores for denoising
            \end{itemize}
        \end{column}
        \begin{column}{0.5\textwidth}
            \textbf{Performance Impact:}
            \begin{itemize}
                \item 10-100x speedup over compute shaders
                \item Real-time ray tracing in games
                \item Interactive path tracing
                \item AI-accelerated denoising
            \end{itemize}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}{RTX Architecture Deep Dive}
    \begin{center}
        \begin{tikzpicture}[scale=0.8]
            % GPU die representation
            \draw[thick, PrimaryColor] (0,0) rectangle (8,5);
            \node[above] at (4,5.3) {\textbf{RTX GPU Architecture}};

            % Streaming Multiprocessors
            \foreach \x in {0.5,2.5,4.5,6.5} {
                    \draw[SecondaryColor, thick] (\x,3.5) rectangle (\x+1.5,4.8);
                    \node at (\x+0.75,4.15) {\textcolor{SecondaryColor}{\textbf{SM}}};
                }

            % RT Cores
            \foreach \x in {1,3,5,7} {
                    \draw[AccentColor, thick, fill=AccentColor!20] (\x,2.5) rectangle (\x+0.8,3.2);
                    \node at (\x+0.4,2.85) {\textcolor{AccentColor}{\textbf{RT}}};
                }

            % Tensor Cores
            \foreach \x in {0.5,2.5,4.5,6.5} {
                    \draw[RayColor, thick, fill=RayColor!20] (\x,1.5) rectangle (\x+1.5,2.2);
                    \node at (\x+0.75,1.85) {\textcolor{RayColor}{\textbf{Tensor}}};
                }

            % Memory
            \draw[ObjectColor, thick] (0.5,0.3) rectangle (7.5,1.2);
            \node at (4,0.75) {\textcolor{ObjectColor}{\textbf{GDDR6 Memory}}};

            % Labels
            \node[right] at (8.2,4.15) {\textcolor{SecondaryColor}{Shader Cores}};
            \node[right] at (8.2,2.85) {\textcolor{AccentColor}{Ray Tracing}};
            \node[right] at (8.2,1.85) {\textcolor{RayColor}{AI Denoising}};
            \node[right] at (8.2,0.75) {\textcolor{ObjectColor}{High Bandwidth}};
        \end{tikzpicture}
    \end{center}

    \begin{raybox}{RT Core Functions}
        \textbf{Hardware accelerated:} BVH traversal, ray-triangle intersection, ray-box intersection\\
        \textbf{Result:} Massive parallel ray processing with dedicated silicon
    \end{raybox}
\end{frame}

\begin{frame}{Modern Ray Tracing APIs}
    \begin{columns}
        \begin{column}{0.5\textwidth}
            \begin{conceptbox}{DirectX Raytracing (DXR)}
                \textbf{Microsoft's API:}
                \begin{itemize}
                    \item Raytracing Pipeline State Objects
                    \item Acceleration Structure builds
                    \item Ray generation/intersection/hit shaders
                    \item Widely adopted in games
                \end{itemize}
            \end{conceptbox}

            \vspace{0.3cm}
            \begin{conceptbox}{Vulkan Ray Tracing}
                \textbf{Cross-platform standard:}
                \begin{itemize}
                    \item VK\_KHR\_ray\_tracing\_pipeline
                    \item Lower-level control
                    \item Multi-vendor support
                    \item Mobile and desktop
                \end{itemize}
            \end{conceptbox}
        \end{column}
        \begin{column}{0.5\textwidth}
            \begin{tikzpicture}[scale=0.7]
                % API stack
                \node[rectangle, draw, fill=PrimaryColor!20, minimum width=4cm, minimum height=0.8cm] (app) at (0,3) {Application};
                \node[rectangle, draw, fill=SecondaryColor!20, minimum width=4cm, minimum height=0.8cm] (api) at (0,2) {DXR / Vulkan RT};
                \node[rectangle, draw, fill=AccentColor!20, minimum width=4cm, minimum height=0.8cm] (driver) at (0,1) {GPU Driver};
                \node[rectangle, draw, fill=ObjectColor!20, minimum width=4cm, minimum height=0.8cm] (hw) at (0,0) {RT Hardware};

                % Arrows
                \draw[arrow] (app) -- (api);
                \draw[arrow] (api) -- (driver);
                \draw[arrow] (driver) -- (hw);

                % Side annotations
                \node[right] at (2.2,3) {\small Game/Engine};
                \node[right] at (2.2,2) {\small Standard API};
                \node[right] at (2.2,1) {\small Optimization};
                \node[right] at (2.2,0) {\small RT Cores};
            \end{tikzpicture}

            \vspace{0.5cm}
            \textbf{Key Innovation:}
            \begin{itemize}
                \item Shader-driven ray tracing
                \item Flexible hit/miss handling
                \item Integration with rasterization
                \item Real-time performance
            \end{itemize}
        \end{column}
    \end{columns}
\end{frame}

% --- Section 11: Path Tracing ---
\section{Path Tracing: The Ultimate Goal}

\begin{frame}{Beyond Ray Tracing: Path Tracing}
    \begin{center}
        \begin{tikzpicture}[scale=0.8]
            % Scene setup
            \node[circle, fill=LightColor, minimum size=1cm] (light) at (1,4) {\faIcon{sun}};
            \node[sphere] (sphere1) at (3,2) {};
            \node[sphere] (sphere2) at (5,1) {};
            \node[eye] (eye) at (7,2) {\faIcon{eye}};

            % Multiple path samples
            \draw[ray, bend left=10] (eye) to (sphere2);
            \draw[reflectray, bend right=15] (sphere2) to (sphere1);
            \draw[lightray, bend left=20] (sphere1) to (light);

            \draw[ray, bend left=20] (eye) to (sphere2);
            \draw[reflectray, bend left=10] (sphere2) to (3,4);
            \draw[lightray] (3,4) to (light);

            \draw[ray, bend right=10] (eye) to (sphere2);
            \draw[reflectray, bend right=25] (sphere2) to (sphere1);
            \draw[refractray, bend left=15] (sphere1) to (2,0);

            % Path labels
            \node[below] at (4,-0.5) {\raycolor{\textbf{Multiple Random Paths}}};
            \node[above] at (4,4.8) {\textcolor{LightColor}{\textbf{Monte Carlo Integration}}};
        \end{tikzpicture}
    \end{center}

    \begin{columns}
        \begin{column}{0.5\textwidth}
            \begin{raybox}{Ray Tracing Limitations}
                \begin{itemize}
                    \item Perfect mirrors only
                    \item Direct illumination focus
                    \item Limited global effects
                    \item Deterministic sampling
                \end{itemize}
            \end{raybox}
        \end{column}
        \begin{column}{0.5\textwidth}
            \begin{raybox}{Path Tracing Advantages}
                \begin{itemize}
                    \item Physically accurate lighting
                    \item Global illumination
                    \item Soft shadows, caustics
                    \item Unbiased rendering
                \end{itemize}
            \end{raybox}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}{The Rendering Equation}
    \begin{center}
        \begin{mathbox}{The Holy Grail of Computer Graphics}
            \begin{align}
                L_o(\mathbf{p}, \omega_o) = L_e(\mathbf{p}, \omega_o) + \int_\Omega f(\mathbf{p}, \omega_i, \omega_o) L_i(\mathbf{p}, \omega_i) (\mathbf{n} \cdot \omega_i) d\omega_i
            \end{align}
        \end{mathbox}
    \end{center}

    \begin{columns}
        \begin{column}{0.5\textwidth}
            \textbf{Components:}
            \begin{itemize}
                \item $L_o$ = Outgoing radiance
                \item $L_e$ = Emitted light
                \item $f$ = BRDF (material properties)
                \item $L_i$ = Incoming radiance
                \item $\Omega$ = Hemisphere of directions
            \end{itemize}
        \end{column}
        \begin{column}{0.5\textwidth}
            \begin{tikzpicture}[scale=0.7]
                % Surface point
                \draw[thick, ObjectColor] (-1,0) -- (3,0);
                \fill[AccentColor] (1,0) circle (3pt);
                \node[below] at (1,-0.3) {$\mathbf{p}$};

                % Normal
                \draw[->, SecondaryColor, thick] (1,0) -- (1,1.5);
                \node[right] at (1,1.5) {$\mathbf{n}$};

                % Incoming light hemisphere
                \draw[lightray] (0,1.2) -- (1,0);
                \draw[lightray] (0.5,1.5) -- (1,0);
                \draw[lightray] (1.5,1.5) -- (1,0);
                \draw[lightray] (2,1.2) -- (1,0);

                % Outgoing direction
                \draw[->, RayColor, thick] (1,0) -- (0.3,1);
                \node[left] at (0.3,1) {$\omega_o$};

                % Hemisphere
                \draw[dashed] (1,0) circle (1.2);
                \node[above] at (1,1.8) {\small Hemisphere $\Omega$};
            \end{tikzpicture}
        \end{column}
    \end{columns}

    \begin{conceptbox}{The Challenge}
        \textbf{Integral:} Infinite directions to sample → Monte Carlo approximation needed
    \end{conceptbox}
\end{frame}

\begin{frame}{Path Tracing vs Ray Tracing}
    \begin{center}
        \begin{tikzpicture}[scale=0.7]
            % Ray Tracing side
            \node[above] at (-2,3) {\textbf{Ray Tracing}};
            \node[eye] (eye1) at (-4,1) {};
            \node[triangle] (near1) at (-2,1.2) {};
            \node[triangle] (far1) at (-1,1) {};
            \draw[ray] (eye1) -- (-2,1.5) -- (-0.5,1.2);
            \draw[ray] (eye1) -- (-2,0.5) -- (-0.5,0.8);
            \node[below] at (-3,0.2) {\small Converging rays};
            \node[below] at (-3,-0.1) {\small Size $\propto$ 1/distance};

            % vs
            \node at (0,1) {\huge \textcolor{AccentColor}{vs}};

            % Path Tracing side
            \node[above] at (2,3) {\textbf{Path Tracing}};
            \node[eye] (eye2) at (0.5,1) {};
            \node[sphere] (obj2) at (2,1) {};
            \node[sphere] (obj3) at (3,2) {};
            \node[circle, fill=LightColor, minimum size=0.6cm] (light2) at (4,0.5) {};

            % Multiple random paths
            \draw[ray, bend left=10] (eye2) to (sphere2);
            \draw[reflectray, bend right=15] (sphere2) to (sphere1);
            \draw[lightray, bend left=20] (sphere1) to (light);

            \draw[ray, bend left=20] (eye2) to (sphere2);
            \draw[reflectray, bend left=10] (sphere2) to (3,4);
            \draw[lightray] (3,4) to (light);

            \draw[ray, bend right=10] (eye2) to (sphere2);
            \draw[reflectray, bend right=25] (sphere2) to (sphere1);
            \draw[refractray, bend left=15] (sphere1) to (2,0);

            % Path labels
            \node[below] at (4,-0.5) {\raycolor{\textbf{Multiple Random Paths}}};
            \node[above] at (4,4.8) {\textcolor{LightColor}{\textbf{Monte Carlo Integration}}};
        \end{tikzpicture}
    \end{center}

    \begin{columns}
        \begin{column}{0.5\textwidth}
            \begin{raybox}{Ray Tracing Limitations}
                \begin{itemize}
                    \item Perfect mirrors only
                    \item Direct illumination focus
                    \item Limited global effects
                    \item Deterministic sampling
                \end{itemize}
            \end{raybox}
        \end{column}
        \begin{column}{0.5\textwidth}
            \begin{raybox}{Path Tracing Advantages}
                \begin{itemize}
                    \item Physically accurate lighting
                    \item Global illumination
                    \item Soft shadows, caustics
                    \item Unbiased rendering
                \end{itemize}
            \end{raybox}
        \end{column}
    \end{columns}
\end{frame}

% --- Section 12: Shading Models Preview ---
\section{The Art of Shading (Preview)}

\begin{frame}{From Geometry to Beauty}
    \begin{center}
        \large \textcolor{PrimaryColor}{We've traced rays and found intersections...}\\
        \vspace{0.5cm}
        \huge \textcolor{AccentColor}{Now what color should that pixel be?}
    \end{center}

    \begin{columns}
        \begin{column}{0.5\textwidth}
            \begin{tikzpicture}[scale=0.8]
                % Simple sphere with different shading
                \draw[thick, ObjectColor] (0,0) circle (1.5);

                % Light direction
                \node[circle, fill=LightColor, minimum size=0.6cm] (light) at (-1,2) {};
                \draw[lightray] (light) -- (0,0.8);

                % Normal at surface
                \draw[->, SecondaryColor, thick] (0,0.8) -- (-0.3,1.5);
                \node[left] at (-0.3,1.5) {$\mathbf{n}$};

                % Eye direction
                \node[eye] (eye) at (3,1) {};
                \draw[ray] (eye) -- (0,0.8);

                \node[below] at (0,-2) {\textcolor{ObjectColor}{\textbf{The intersection is just the beginning}}};
            \end{tikzpicture}
        \end{column}
        \begin{column}{0.5\textwidth}
            \textbf{Shading determines:}
            \begin{itemize}
                \item Surface appearance
                \item Material properties
                \item Light interaction
                \item Visual realism
            \end{itemize}

            \vspace{0.5cm}
            \alert{Next lesson:} Deep dive into shading models!
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}{Shading Models: A Sneak Peek}
    \begin{center}
        \begin{tikzpicture}[scale=0.7]
            % Phong model illustration
            \node[above] at (-3,2.5) {\textbf{Phong Model}};
            \node[sphere] (phong) at (-3,1) {};
            \draw[lightray] (-4,2) -- (phong);
            \draw[ray] (-1,1) -- (phong);
            \node[below] at (-3,0) {\textcolor{SecondaryColor}{Ad-hoc but fast}};

            % PBR illustration  
            \node[above] at (0,2.5) {\textbf{Physically Based}};
            \node[sphere] (pbr) at (0,1) {};
            \draw[lightray] (-1,2) -- (pbr);
            \draw[reflectray] (pbr) -- (1,2);
            \draw[ray] (2,1) -- (pbr);
            \node[below] at (0,0) {\textcolor{AccentColor}{Physically accurate}};

            % Advanced illustration
            \node[above] at (3,2.5) {\textbf{Advanced}};
            \node[sphere] (adv) at (3,1) {};
            \draw[lightray] (2,2) -- (adv);
            \draw[refractray] (adv) -- (3.5,0.2);
            \draw[reflectray] (adv) -- (4,1.8);
            \node[below] at (3,0) {\textcolor{RayColor}{Subsurface, etc.}};
        \end{tikzpicture}
    \end{center}

    \begin{columns}
        \begin{column}{0.33\textwidth}
            \begin{conceptbox}{Phong/Blinn-Phong}
                \textbf{Components:}
                \begin{itemize}
                    \item Ambient
                    \item Diffuse
                    \item Specular
                \end{itemize}
                \textbf{Pro:} Fast, simple\\
                \textbf{Con:} Not physically accurate
            \end{conceptbox}
        \end{column}
        \begin{column}{0.33\textwidth}
            \begin{conceptbox}{Physically Based}
                \textbf{Based on:}
                \begin{itemize}
                    \item Energy conservation
                    \item Fresnel equations
                    \item Microfacet theory
                \end{itemize}
                \textbf{Pro:} Realistic, consistent\\
                \textbf{Con:} More complex
            \end{conceptbox}
        \end{column}
        \begin{column}{0.33\textwidth}
            \begin{conceptbox}{Advanced Models}
                \textbf{Features:}
                \begin{itemize}
                    \item Subsurface scattering
                    \item Volumetric effects
                    \item Layered materials
                \end{itemize}
                \textbf{Pro:} Ultimate realism\\
                \textbf{Con:} Computationally expensive
            \end{conceptbox}
        \end{column}
    \end{columns}
\end{frame}

% --- Section 13: Applications and Future ---
\section{Applications and Future}

\begin{frame}{Ray Tracing in the Real World}
    \begin{center}
        \begin{tikzpicture}[scale=0.8]
            % Applications
            \node[rectangle, rounded corners, fill=PrimaryColor!20, minimum width=2.5cm, minimum height=1.5cm] (movies) at (0,2) {Movies \& VFX};
            \node[rectangle, rounded corners, fill=SecondaryColor!20, minimum width=2.5cm, minimum height=1.5cm] (games) at (4,2) {Video Games};
            \node[rectangle, rounded corners, fill=AccentColor!20, minimum width=2.5cm, minimum height=1.5cm] (arch) at (0,0) {Architecture};
            \node[rectangle, rounded corners, fill=ObjectColor!20, minimum width=2.5cm, minimum height=1.5cm] (product) at (4,0) {Product Design};

            % Center
            \node[circle, fill=LightColor, minimum size=2cm] (center) at (2,1) {\textbf{Ray Tracing}};

            % Connections
            \draw[arrow] (center) -- (movies);
            \draw[arrow] (center) -- (games);
            \draw[arrow] (center) -- (arch);
            \draw[arrow] (center) -- (product);

            % Icons
            \node at (0,2.5) {\faIcon{film}};
            \node at (4,2.5) {\faIcon{gamepad}};
            \node at (0,0.5) {\faIcon{building}};
            \node at (4,0.5) {\faIcon{car}};
        \end{tikzpicture}
    \end{center}

    \begin{columns}
        \begin{column}{0.5\textwidth}
            \textbf{Traditional (Offline):}
            \begin{itemize}
                \item Movie rendering
                \item Architectural visualization
                \item Product design
                \item Scientific simulation
            \end{itemize}
        \end{column}
        \begin{column}{0.5\textwidth}
            \textbf{Modern (Real-time):}
            \begin{itemize}
                \item RTX graphics cards
                \item Video games
                \item VR/AR applications
                \item Interactive design
            \end{itemize}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}{The Future is Bright}
    \begin{conceptbox}{Hardware Acceleration}
        \textbf{Modern GPUs:} Dedicated ray tracing cores, massive parallelization
    \end{conceptbox}

    \vspace{0.3cm}

    \begin{columns}
        \begin{column}{0.5\textwidth}
            \textbf{Emerging Techniques:}
            \begin{itemize}
                \item Machine learning denoising
                \item Hybrid rendering
                \item Path tracing
                \item Photon mapping
            \end{itemize}
        \end{column}
        \begin{column}{0.5\textwidth}
            \textbf{New Applications:}
            \begin{itemize}
                \item Medical imaging
                \item Autonomous vehicles
                \item Metaverse platforms
                \item Scientific visualization
            \end{itemize}
        \end{column}
    \end{columns}

    \vspace{0.5cm}

    \begin{center}
        \large \textcolor{PrimaryColor}{\textbf{Ray tracing is becoming the future of computer graphics!}}
    \end{center}
\end{frame}

% --- Conclusion ---
\section{Wrapping Up}

\begin{frame}{Key Takeaways}
    \begin{enumerate}
        \item \highlight{Ray tracing simulates light transport} by reversing the natural process
        \item \highlight{Mathematical foundation} involves solving intersection equations for different geometric primitives
        \item \highlight{Secondary rays} enable realistic effects like reflections, refractions, and shadows
        \item \highlight{Implementation challenges} include floating-point precision and performance optimization
        \item \highlight{Real-world impact} spans from Hollywood movies to real-time gaming
    \end{enumerate}

    \vspace{0.5cm}

    \begin{center}
        \begin{tikzpicture}[scale=0.6]
            % Final illustration
            \node[eye] (eye) at (0,0) {\faIcon{eye}};
            \node[sphere] at (2,0) {};
            \node[sphere] at (3,1) {};
            \node[triangle] at (4,-1) {};
            \node[circle, fill=LightColor, minimum size=0.8cm] at (2,2) {\faIcon{lightbulb}};

            \draw[ray] (eye) -- (2,0) -- (4,1);
            \draw[reflectray] (2,0) -- (3,1);
            \draw[shadowray] (2,0) -- (2,2);
            \draw[refractray] (2,0) -- (4,-1);

            \node[below] at (2,-2) {\textcolor{PrimaryColor}{\textbf{The art and science of light}}};
        \end{tikzpicture}
    \end{center}
\end{frame}
\end{document}